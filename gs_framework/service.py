# -*- coding: UTF-8 -*-
"""
Env / Task 的基类对象
"""
import asyncio
import functools
import inspect
import logging
from typing import Callable, Any, Dict, Union, Awaitable, Optional, Mapping, List, Tuple

from faust import App
from faust.types import AppT, TP
from .instance_hash_calculation import HashCalculation

from .stateful_interfaces import OBJECT_STATE_READER, AppIdMixin

from .object_reference import ObjectRef
from .state_storage import StateStreamStorage
from .state_stream import ObjectStateStream

from .faust_utilities import FaustUtilities
from .stateful_object import StatefulObject
from .timer_handler import TimerHandler
from .crontab_handler import CrontabHandler

logger = logging.getLogger(__name__)


class StateVarSources:
    """
    Each service creates its own faust app, whose id is generated by the pk of the service instance (for stateful
     service), or passed in (for stateless service).

    All the StreamComponents objects (in types of :func:`StreamComponentsMixin.stream_component_types`)
    should be defined as class level members so that:
    -- they will be cloned to instance level members by :func:`StreamComponentsMixin.__init__`
    -- decorator state_var_change_handler can use the class member as state_var_source. function
        StateVarChangeDispatcher._collect_variable_change_handlers convert the class member to its member name
    """

    FUNC_STATE_VAR_CHANGE_DISPATCHER = Callable[[Any, Dict[str, Any], str], Awaitable[None]]
    """
    The parameters are (from left to right):
    state_var_owner_pk: pk of object the state vars belong to
    state_vars: name and values for changed state variable
    state_var_source_name: name of state_var_source
    """

    source_types = (ObjectStateStream, StateStreamStorage, ObjectRef)

    @staticmethod
    def initialize(app: AppT, service_object: object,
                   state_var_change_dispatcher: FUNC_STATE_VAR_CHANGE_DISPATCHER):
        """
        All the instance StreamComponents object members should be initialized by explicitly call this function
        """

        async def state_var_change_observer(state_var_source_name: Optional[str], object_pk: Any,
                                            object_state_vars: Dict[str, Any], headers: Mapping[str, Any],
                                            object_pk_bytes: bytes):
            if object_state_vars is not None:
                await state_var_change_dispatcher(object_pk, object_state_vars, state_var_source_name)

        for member_name, member in filter(lambda name_and_member:
                                          isinstance(name_and_member[1], StateVarSources.source_types),
                                          map(lambda attr_name:
                                              (attr_name, getattr(service_object, attr_name)),
                                              dir(service_object))):
            if isinstance(member, (StateStreamStorage, ObjectRef)):
                member.initialize(app, member_name, functools.partial(state_var_change_observer, member_name))
            else:
                assert isinstance(member, ObjectStateStream)
                member.initialize(app, functools.partial(state_var_change_observer, member_name),
                                  f"agent_of_member_{member_name}")


class ServiceUnit:
    """Represent a set of functions in a service"""

    def __init__(self):
        super().__init__()
        self._app: App = None

    @property
    def app(self) -> App:
        return self._app

    def initialize(self, app: App, on_handlers_called: Optional[Callable[[], Union[Awaitable[None], None]]]):
        self._app = app

        from .state_var_change_dispatcher import StateVarChangeDispatcher

        state_var_change_dispatcher = StateVarChangeDispatcher(self, on_handlers_called)
        StateVarSources.initialize(app, self, state_var_change_dispatcher.on_state_var_changes)

        CrontabHandler.init_faust_crontabs(app, self, on_handlers_called)
        TimerHandler.init_faust_timers(app, self, on_handlers_called)


class Service(ServiceUnit):

    def __init__(self):
        super().__init__()
        self._service_add_ons: List[ServiceUnit] = None

    def add_service_units(self, *add_ons: ServiceUnit):
        if self._service_add_ons is None:
            self._service_add_ons = list()
        self._service_add_ons.extend(add_ons)

    async def _start(self, app_id: str, on_handlers_called: Optional[Callable[[], Union[Awaitable[None], None]]]):
        app = FaustUtilities.create_faust_app(app_id)
        super().initialize(app, on_handlers_called)

        if self._service_add_ons is not None:
            for add_on in self._service_add_ons:
                add_on.initialize(app, on_handlers_called)

        await app.start()

    async def stop(self):
        await self._app.stop()


class StatefulService(Service, StatefulObject):

    state_vars_storage: StateStreamStorage = StateStreamStorage.bind_at_runtime()

    def __new__(cls, *args, **kwargs):
        self = super().__new__(cls)
        setattr(self, '_pk', HashCalculation.calc_inst_hash(cls, *args, **kwargs))
        return self

    def __init__(self):
        super().__init__()
        self._cb_post_start: Optional[Callable[[], Union[None, Awaitable[None]]]] = None

    def bind(self, *, stream_as_template: Optional[ObjectStateStream] = None, topic_define: Optional[TP] = None):
        self_pk_bytes = self._object_pk_bytes

        memory_only_state_variable_names = set(map(lambda v: v.name,
                                                   filter(lambda v: v.memory_only,
                                                          self.get_all_instance_state_vars())))

        def transform_var_name_value(name_and_value: Tuple[str, Any]) \
                -> Tuple[str, StateStreamStorage.TransformedResult]:
            var_name, var_value = name_and_value
            transform_result = StateStreamStorage.TransformedResult(var_value,
                                                                    var_name in memory_only_state_variable_names)
            return var_name, transform_result

        def self_state_var_transformer(state_reader: OBJECT_STATE_READER, object_pk: Any,
                                       object_state_vars: Mapping[str, Any], headers: Mapping[str, Any],
                                       object_pk_bytes: bytes):
            # object_pk_bytes is None means called from handler of in memory channel
            if object_pk_bytes is None or self_pk_bytes == object_pk_bytes:
                value_and_memory_only_dict = dict(map(transform_var_name_value, object_state_vars.items()))
                return value_and_memory_only_dict if len(value_and_memory_only_dict) > 0 else None
            else:
                return None

        self.state_vars_storage.bind(stream_as_template=stream_as_template, topic_define=topic_define,
                                     stateful_transformer=self_state_var_transformer,
                                     forward_through_in_mem_channel=True)

    async def start(self):
        await super()._start(f"app-{self.pk}", self.commit_state_var_changes)

        # note that self._state_var_committer.initialize has to be called after StateVarSources.initialize
        # because self.state_var_storage.stream is initialized by StateVarSources.initialize
        state_vars_storage = self.state_vars_storage
        pk = self.pk

        def get_state_var(name: str, default_val: Any = None) -> Any:
            return state_vars_storage.storage.read_state_var(pk, name, default_val)

        super().initialize_state(get_state_var)

        if self._cb_post_start is not None:
            res = self._cb_post_start()
            if inspect.isawaitable(res):
                await res

    def commit_state_var_changes(self) -> asyncio.Future:
        state_vars_storage = self.state_vars_storage
        return super().commit_state_var_changes(state_vars_storage.stream, state_vars_storage.in_mem_channel_stream)

    def publish_all_state_variables(self) -> asyncio.Future:
        self.mark_all_state_variable_changed()
        return self.commit_state_var_changes()


class StatelessService(Service, AppIdMixin):

    def __new__(cls, *args, **kwargs):
        self = super().__new__(cls)
        inst_hash = HashCalculation.calc_inst_hash(cls, *args, **kwargs)
        setattr(self, '_app_id', f"app-{inst_hash}")
        return self

    async def start(self):
        assert self.app_id is not None
        await super()._start(self.app_id, None)
